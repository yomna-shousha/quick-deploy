import fs from 'fs-extra';
import { BaseBuilder, BuildConfig, BuildResult } from './BaseBuilder.js';

export class StaticSiteBuilder extends BaseBuilder {
  async configure(): Promise<void> {
    this.logger.info('Configuring static site for Cloudflare Workers...');
    
    try {
      await this.createAssetsIgnore();
      await this.createWorkerScript();
      await this.createWranglerConfig();
      this.logger.success('Static site configured for Cloudflare Workers');
    } catch (error) {
      this.logger.error('Failed to configure static site:', error);
      throw error;
    }
  }

  async build(config: BuildConfig): Promise<BuildResult> {
    this.logger.info('Preparing static site...');

    try {
      // Static sites don't need building - files are already ready
      const buildDir = await this.findStaticFiles();

      return {
        success: true,
        buildDir,
        deploymentType: 'static'
      };
    } catch (error) {
      this.logger.error('Static site preparation failed:', error);
      throw error;
    }
  }

  private async createAssetsIgnore(): Promise<void> {
    if (!await fs.pathExists('.assetsignore')) {
      const assetsIgnoreContent = `# Auto-generated by quick-deploy for static sites
# Exclude git files and development artifacts from deployment

# Version control
.git/
.gitignore
.gitattributes

# Development files  
node_modules/
.env*
.DS_Store
Thumbs.db

# Build artifacts
dist/
build/
.cache/
.temp/
.tmp/

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# Logs
*.log
logs/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Documentation and config (typically not needed for deployment)
README.md
README.txt
LICENSE*
*.md
.editorconfig
.eslintrc*
.prettierrc*
package*.json
yarn.lock
pnpm-lock.yaml
bun.lockb

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Backup files
*.bak
*.backup
*.orig`;

      await fs.writeFile('.assetsignore', assetsIgnoreContent);
      this.logger.info('Created .assetsignore to exclude development files');
    } else {
      this.logger.info('Using existing .assetsignore file');
    }
  }

  private async createWorkerScript(): Promise<void> {
    if (!await fs.pathExists('worker.js')) {
      const workerScript = `// Static site worker for Cloudflare Workers
// Auto-generated by quick-deploy

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      let pathname = url.pathname;
      
      // Handle root path
      if (pathname === '/') {
        pathname = '/index.html';
      }
      
      // Add .html extension for clean URLs if file doesn't have extension
      if (!pathname.includes('.') && !pathname.endsWith('/')) {
        pathname += '.html';
      }
      
      // Try to get the file from assets
      try {
        const response = await env.ASSETS.fetch(new URL(pathname, request.url));
        
        // If successful, return with proper headers
        if (response.ok) {
          const newResponse = new Response(response.body, response);
          
          // Set proper content type based on file extension
          const ext = pathname.split('.').pop()?.toLowerCase();
          const contentTypes = {
            'html': 'text/html; charset=utf-8',
            'css': 'text/css',
            'js': 'application/javascript',
            'json': 'application/json',
            'png': 'image/png',
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg',
            'gif': 'image/gif',
            'svg': 'image/svg+xml',
            'ico': 'image/x-icon',
            'pdf': 'application/pdf',
            'mp4': 'video/mp4',
            'mov': 'video/quicktime'
          };
          
          if (ext && contentTypes[ext]) {
            newResponse.headers.set('Content-Type', contentTypes[ext]);
          }
          
          // Add caching headers
          newResponse.headers.set('Cache-Control', 'public, max-age=3600');
          
          return newResponse;
        }
      } catch (assetError) {
        console.log('Asset fetch failed:', assetError);
      }
      
      // If file not found, try to serve index.html for SPA routing
      if (pathname !== '/index.html') {
        try {
          const indexResponse = await env.ASSETS.fetch(new URL('/index.html', request.url));
          if (indexResponse.ok) {
            return new Response(indexResponse.body, {
              ...indexResponse,
              headers: {
                ...Object.fromEntries(indexResponse.headers.entries()),
                'Content-Type': 'text/html; charset=utf-8'
              }
            });
          }
        } catch (indexError) {
          console.log('Index.html fetch failed:', indexError);
        }
      }
      
      // Return 404 if nothing found
      return new Response(\`<!DOCTYPE html>
<html>
<head>
  <title>404 - Not Found</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
    h1 { color: #333; }
  </style>
</head>
<body>
  <h1>404 - Page Not Found</h1>
  <p>The requested page could not be found.</p>
  <a href="/">Go back home</a>
</body>
</html>\`, {
        status: 404,
        headers: { 'Content-Type': 'text/html; charset=utf-8' }
      });
      
    } catch (error) {
      console.error('Worker error:', error);
      return new Response('Internal Server Error', { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
};`;

      await fs.writeFile('worker.js', workerScript);
      this.logger.info('Created worker.js for static site serving');
    }
  }

  private async createWranglerConfig(): Promise<void> {
    if (!await fs.pathExists('wrangler.jsonc')) {
      const projectName = await this.getProjectName();
      
      const wranglerConfig = {
        "name": projectName,
        "main": "./worker.js",
        "compatibility_date": new Date().toISOString().split('T')[0],
        "assets": {
          "binding": "ASSETS",
          "directory": "./"
        },
        "observability": {
          "enabled": true
        }
      };

      await fs.writeJson('wrangler.jsonc', wranglerConfig, { spaces: 2 });
      this.logger.info('Created wrangler.jsonc for Cloudflare Workers');
    }
  }

  private async findStaticFiles(): Promise<string> {
    this.logger.info('Locating static files...');

    // Check for common static site structures
    const possibleDirs = [
      '.', // Root directory (most common for static sites)
      'public',
      'dist',
      'build',
      '_site', // Jekyll
      'out' // Some static generators
    ];

    for (const dir of possibleDirs) {
      if (await fs.pathExists(dir)) {
        // Check if it contains an index.html
        const indexPath = dir === '.' ? 'index.html' : `${dir}/index.html`;
        if (await fs.pathExists(indexPath)) {
          this.logger.success(`Using ${dir === '.' ? 'root directory' : dir + '/'} as static files location`);
          return dir;
        }
      }
    }

    throw new Error('No index.html found. Static sites require an index.html file.');
  }

  private async getProjectName(): Promise<string> {
    // Try to get name from directory
    const currentDir = process.cwd();
    const dirName = currentDir.split('/').pop() || 'static-site';
    
    // Clean the name for Cloudflare (alphanumeric and hyphens only)
    return dirName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
  }
}
